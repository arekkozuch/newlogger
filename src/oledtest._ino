#include <Arduino.h>
#include <SparkFun_u-blox_GNSS_Arduino_Library.h>
#include <WiFi.h>
#include <WiFiUdp.h>
#include <Wire.h>
#include <SparkFun_MAX1704x_Fuel_Gauge_Arduino_Library.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLE2902.h>
#include <FS.h>
#include <SD_MMC.h>
#include <SPI.h>
#include <Preferences.h>
#include <FastLED.h>
#include <U8g2lib.h>

// FastLED Configuration for built-in WS2812
#define LED_PIN 46        // Pin 46 on Thing Plus C S3 is connected to WS2812 LED
#define COLOR_ORDER GRB
#define CHIPSET WS2812
#define NUM_LEDS 1
#define BRIGHTNESS 25
CRGB leds[NUM_LEDS];

// BLE Service and Characteristic UUIDs
const char* telemetryServiceUUID = "6e400001-b5a3-f393-e0a9-e50e24dcca9e";
const char* telemetryCharUUID    = "6e400003-b5a3-f393-e0a9-e50e24dcca9e";
const char* configCharUUID       = "6e400002-b5a3-f393-e0a9-e50e24dcca9e";
const char* fileTransferCharUUID = "6e400005-b5a3-f393-e0a9-e50e24dcca9e";

// Hardware Configuration
SFE_MAX1704X lipo;
SFE_UBLOX_GNSS myGNSS;
Preferences preferences;
// SH1106 OLED display (I2C)
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/ U8X8_PIN_NONE);

// Pin Definitions for ESP32-S3 Thing Plus
#define GNSS_RX 4
#define GNSS_TX 2
#define SD_DETECT 48

#define BUTTON_A_PIN 6
#define BUTTON_B_PIN 21
HardwareSerial GNSS_Serial(2);

// Button and Menu System
enum MenuState {
  MENU_MAIN,
  MENU_GPS_INFO,
  MENU_BATTERY_INFO,
  MENU_SYSTEM_INFO,
  MENU_FILE_BROWSER,
  MENU_SETTINGS
};

struct ButtonState {
  int lastState = HIGH;
  unsigned long lastDebounceTime = 0;
  bool pressed = false;
  bool longPressed = false;
  bool longPressActive = false;
};

ButtonState buttonA, buttonB;
MenuState currentMenu = MENU_MAIN;
int menuSelection = 0;
unsigned long lastDisplayUpdate = 0;
bool displayNeedsUpdate = true;
const unsigned long debounceDelay = 50;
const unsigned long longPressDelay = 1000;

// SDIO pins for ESP32-S3 Thing Plus
int pin_sdioCLK = 38;
int pin_sdioCMD = 34;
int pin_sdioD0 = 39;
int pin_sdioD1 = 40;
int pin_sdioD2 = 47;
int pin_sdioD3 = 33;

// WiFi Configuration
const char* ssid = "Puchatkova";
const char* password = "Internet2@";
const IPAddress remoteIP(172, 16, 2, 158);
const uint16_t remotePort = 9000;
WiFiUDP udp;

// BLE Configuration
BLECharacteristic* telemetryChar = nullptr;
BLECharacteristic* configChar = nullptr;
BLECharacteristic* fileTransferChar = nullptr;
BLE2902* telemetryDescriptor = nullptr;

// SD Card and Logging
File logFile;
bool sdCardAvailable = false;
bool loggingActive = false;
char currentLogFilename[64] = "";

// File Transfer State
struct FileTransferState {
  bool active = false;
  File transferFile;
  String filename = "";
  size_t fileSize = 0;
  size_t bytesSent = 0;
  unsigned long lastChunkTime = 0;
  bool listingFiles = false;
} fileTransfer;

// LED Status Management
enum LEDStatus {
  LED_STARTUP,
  LED_NO_GPS,
  LED_GPS_SEARCHING,
  LED_GPS_GOOD,
  LED_LOGGING,
  LED_ERROR,
  LED_LOW_BATTERY,
  LED_FILE_TRANSFER,
  LED_BLE_CONNECTED
};

LEDStatus currentLEDStatus = LED_STARTUP;
unsigned long lastLEDUpdate = 0;
uint8_t ledBrightness = 0;
bool ledDirection = true;

// Enhanced Performance Monitoring
struct PerformanceStats {
  unsigned long totalPackets = 0;
  unsigned long droppedPackets = 0;
  unsigned long sequenceErrors = 0;
  unsigned long minDelta = 9999;
  unsigned long maxDelta = 0;
  unsigned long avgDelta = 0;
  float memoryUsage = 0.0f;
  unsigned long lastResetTime = 0;
} perfStats;

// GPS Packet Structure (30 bytes total: 28 payload + 2 CRC)
struct __attribute__((packed)) GPSPacket {
  uint32_t timestamp;      // Unix epoch (4 bytes)
  int32_t latitude;        // deg * 1e7 (4 bytes)
  int32_t longitude;       // deg * 1e7 (4 bytes)
  int32_t altitude;        // mm (4 bytes)
  uint16_t speed;          // mm/s (2 bytes)
  uint16_t heading;        // deg * 1e2 (2 bytes)
  uint8_t fixType;         // 0-5 (1 byte)
  uint8_t satellites;      // count (1 byte)
  uint16_t battery_mv;     // mV (2 bytes)
  uint8_t battery_pct;     // % (1 byte)
  uint8_t reserved1;       // padding (1 byte)
  uint8_t reserved2;       // padding (1 byte)  
  uint8_t reserved3;       // padding (1 byte) - Total payload: 28 bytes
  uint16_t crc;            // CRC16 (2 bytes) - Total: 30 bytes
};

uint32_t packetSequence = 0;
unsigned long lastMotionTime = 0;

// Button Handling Functions
void updateButton(ButtonState &button, int pin, const char* name) {
  int reading = digitalRead(pin);
  
  // Reset debounce timer if state changed
  if (reading != button.lastState) {
    button.lastDebounceTime = millis();
  }
  
  // Only process if past debounce delay
  if ((millis() - button.lastDebounceTime) > debounceDelay) {
    // Button state has stabilized
    if (reading == LOW && button.lastState == HIGH) {
      // Button just pressed
      button.pressed = true;
      button.longPressActive = false;
      Serial.printf("🎮 Button %s pressed\n", name);
    } else if (reading == HIGH && button.lastState == LOW) {
      // Button just released
      if (button.longPressActive) {
        button.longPressed = true;
        Serial.printf("🎮 Button %s long pressed\n", name);
      }
      button.longPressActive = false;
    }
    
    // Check for long press while button is held down
    if (reading == LOW && (millis() - button.lastDebounceTime) > longPressDelay && !button.longPressActive) {
      button.longPressActive = true;
      button.longPressed = true;
      Serial.printf("🎮 Button %s long press detected\n", name);
    }
  }
  
  button.lastState = reading;
}

void processButtons() {
  updateButton(buttonA, BUTTON_A_PIN, "A");
  updateButton(buttonB, BUTTON_B_PIN, "B");
  
  // Handle button actions
  if (buttonA.pressed) {
    buttonA.pressed = false;
    handleButtonA();
    displayNeedsUpdate = true;
  }
  
  if (buttonB.pressed) {
    buttonB.pressed = false;
    handleButtonB();
    displayNeedsUpdate = true;
  }
  
  if (buttonA.longPressed) {
    buttonA.longPressed = false;
    handleButtonALong();
    displayNeedsUpdate = true;
  }
  
  if (buttonB.longPressed) {
    buttonB.longPressed = false;
    handleButtonBLong();
    displayNeedsUpdate = true;
  }
}

void handleButtonA() {
  // Button A: Navigate/Select
  switch (currentMenu) {
    case MENU_MAIN:
      menuSelection = (menuSelection + 1) % 4; // 4 main menu items
      break;
    case MENU_GPS_INFO:
    case MENU_BATTERY_INFO:
    case MENU_SYSTEM_INFO:
    case MENU_FILE_BROWSER:
    case MENU_SETTINGS:
      currentMenu = MENU_MAIN;
      menuSelection = 0;
      break;
  }
}

void handleButtonB() {
  // Button B: Execute/Enter
  switch (currentMenu) {
    case MENU_MAIN:
      switch (menuSelection) {
        case 0: currentMenu = MENU_GPS_INFO; break;
        case 1: currentMenu = MENU_BATTERY_INFO; break;
        case 2: currentMenu = MENU_SYSTEM_INFO; break;
        case 3: currentMenu = MENU_SETTINGS; break;
      }
      break;
    case MENU_SETTINGS:
      // Toggle logging
      toggleLogging();
      break;
    default:
      currentMenu = MENU_MAIN;
      menuSelection = 0;
      break;
  }
}

void handleButtonALong() {
  // Long press A: Quick toggle logging
  toggleLogging();
}

void handleButtonBLong() {
  // Long press B: Return to main menu
  currentMenu = MENU_MAIN;
  menuSelection = 0;
}

void toggleLogging() {
  if (loggingActive) {
    loggingActive = false;
    if (logFile) {
      logFile.close();
      Serial.println("⚪ Logging stopped");
    }
    if (myGNSS.getFixType() >= 3) {
      setLEDStatus(LED_GPS_GOOD);
    } else {
      setLEDStatus(LED_GPS_SEARCHING);
    }
  } else {
    if (sdCardAvailable && myGNSS.getFixType() >= 2) {
      loggingActive = true;
      createLogFile();
      setLEDStatus(LED_LOGGING);
      Serial.println("🔴 Logging started");
    }
  }
}

// OLED Display Functions
void updateDisplay() {
  if (!displayNeedsUpdate && (millis() - lastDisplayUpdate < 1000)) return;
  
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_5x7_tr);
  
  switch (currentMenu) {
    case MENU_MAIN:
      drawMainMenu();
      break;
    case MENU_GPS_INFO:
      drawGPSInfo();
      break;
    case MENU_BATTERY_INFO:
      drawBatteryInfo();
      break;
    case MENU_SYSTEM_INFO:
      drawSystemInfo();
      break;
    case MENU_SETTINGS:
      drawSettings();
      break;
    default:
      drawMainMenu();
      break;
  }
  
  u8g2.sendBuffer();
  displayNeedsUpdate = false;
  lastDisplayUpdate = millis();
}

void drawMainMenu() {
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 10, "GPS Logger v2.0");
  
  u8g2.setFont(u8g2_font_5x7_tr);
  const char* menuItems[] = {"GPS Info", "Battery", "System", "Settings"};
  
  for (int i = 0; i < 4; i++) {
    int y = 25 + (i * 10);
    if (i == menuSelection) {
      u8g2.drawStr(0, y, ">");
      u8g2.drawStr(10, y, menuItems[i]);
    } else {
      u8g2.drawStr(10, y, menuItems[i]);
    }
  }
  
  // Status indicators at bottom
  u8g2.setFont(u8g2_font_4x6_tr);
  char status[64];
  sprintf(status, "GPS:%s SD:%s LOG:%s", 
    myGNSS.getFixType() >= 3 ? "OK" : "NO",
    sdCardAvailable ? "OK" : "NO",
    loggingActive ? "ON" : "OFF");
  u8g2.drawStr(0, 62, status);
}

void drawGPSInfo() {
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 10, "GPS Information");
  
  u8g2.setFont(u8g2_font_5x7_tr);
  
  char buffer[32];
  
  // Fix type and satellites
  sprintf(buffer, "Fix: %d  Sats: %d", myGNSS.getFixType(), myGNSS.getSIV());
  u8g2.drawStr(0, 22, buffer);
  
  // Coordinates (if fix available)
  if (myGNSS.getFixType() >= 2) {
    double lat = myGNSS.getLatitude() / 10000000.0;
    double lon = myGNSS.getLongitude() / 10000000.0;
    
    sprintf(buffer, "Lat: %.6f", lat);
    u8g2.drawStr(0, 34, buffer);
    
    sprintf(buffer, "Lon: %.6f", lon);
    u8g2.drawStr(0, 46, buffer);
    
    // Speed and altitude
    float speed_kmh = myGNSS.getGroundSpeed() * 0.0036f;
    float alt_m = myGNSS.getAltitude() / 1000.0f;
    sprintf(buffer, "Spd:%.1fkm/h Alt:%.1fm", speed_kmh, alt_m);
    u8g2.drawStr(0, 58, buffer);
  } else {
    u8g2.drawStr(0, 34, "No GPS fix");
    u8g2.drawStr(0, 46, "Searching...");
  }
}

void drawBatteryInfo() {
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 10, "Battery Status");
  
  u8g2.setFont(u8g2_font_5x7_tr);
  
  char buffer[32];
  float voltage = lipo.getVoltage();
  float percentage = lipo.getSOC();
  
  sprintf(buffer, "Voltage: %.2fV", voltage);
  u8g2.drawStr(0, 25, buffer);
  
  sprintf(buffer, "Charge: %.1f%%", percentage);
  u8g2.drawStr(0, 37, buffer);
  
  // Battery level bar
  int barWidth = 100;
  int barHeight = 8;
  int barX = 10;
  int barY = 45;
  
  u8g2.drawFrame(barX, barY, barWidth, barHeight);
  int fillWidth = (int)(barWidth * percentage / 100.0f);
  u8g2.drawBox(barX + 1, barY + 1, fillWidth - 2, barHeight - 2);
  
  // Status
  if (percentage > 75) {
    u8g2.drawStr(0, 62, "Battery: Excellent");
  } else if (percentage > 50) {
    u8g2.drawStr(0, 62, "Battery: Good");
  } else if (percentage > 25) {
    u8g2.drawStr(0, 62, "Battery: Fair");
  } else {
    u8g2.drawStr(0, 62, "Battery: Low!");
  }
}

void drawSystemInfo() {
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 10, "System Status");
  
  u8g2.setFont(u8g2_font_5x7_tr);
  
  char buffer[32];
  
  // WiFi status
  sprintf(buffer, "WiFi: %s", WiFi.status() == WL_CONNECTED ? "Connected" : "Disconnected");
  u8g2.drawStr(0, 22, buffer);
  
  // BLE status
  sprintf(buffer, "BLE: %s", telemetryDescriptor && telemetryDescriptor->getNotifications() ? "Connected" : "Advertising");
  u8g2.drawStr(0, 32, buffer);
  
  // Memory usage
  sprintf(buffer, "RAM: %dKB free", ESP.getFreeHeap() / 1024);
  u8g2.drawStr(0, 42, buffer);
  
  // Uptime
  unsigned long uptime = millis() / 1000;
  sprintf(buffer, "Uptime: %lus", uptime);
  u8g2.drawStr(0, 52, buffer);
  
  // Packet stats
  sprintf(buffer, "Packets: %lu", perfStats.totalPackets);
  u8g2.drawStr(0, 62, buffer);
}

void drawSettings() {
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 10, "Settings");
  
  u8g2.setFont(u8g2_font_5x7_tr);
  
  u8g2.drawStr(0, 25, "Press B to toggle:");
  u8g2.drawStr(0, 37, loggingActive ? "Stop Logging" : "Start Logging");
  
  if (!sdCardAvailable) {
    u8g2.drawStr(0, 49, "No SD Card!");
  } else if (myGNSS.getFixType() < 2) {
    u8g2.drawStr(0, 49, "Need GPS fix!");
  } else {
    u8g2.drawStr(0, 49, "Ready to log");
  }
  
  u8g2.drawStr(0, 61, "Hold A: Quick toggle");
}

// LED Control Functions
void initLED() {
  FastLED.addLeds<CHIPSET, LED_PIN, COLOR_ORDER>(leds, NUM_LEDS).setCorrection(TypicalLEDStrip);
  FastLED.setBrightness(BRIGHTNESS);
  FastLED.clear();
  FastLED.show();
  Serial.println("💡 WS2812 LED initialized");
}

void setLEDStatus(LEDStatus status) {
  currentLEDStatus = status;
  lastLEDUpdate = millis();
}

void updateLED() {
  unsigned long now = millis();
  
  // Update LED every 50ms for smooth animations
  if (now - lastLEDUpdate < 50) return;
  lastLEDUpdate = now;
  
  switch (currentLEDStatus) {
    case LED_STARTUP:
      // Purple breathing effect during startup
      if (ledDirection) {
        ledBrightness += 5;
        if (ledBrightness >= 255) {
          ledBrightness = 255;
          ledDirection = false;
        }
      } else {
        ledBrightness -= 5;
        if (ledBrightness <= 0) {
          ledBrightness = 0;
          ledDirection = true;
        }
      }
      leds[0] = CRGB(ledBrightness, 0, ledBrightness); // Purple
      break;
      
    case LED_NO_GPS:
      // Red blinking - no GPS module
      leds[0] = ((now / 500) % 2) ? CRGB::Red : CRGB::Black;
      break;
      
    case LED_GPS_SEARCHING:
      // Orange blinking - searching for satellites
      leds[0] = ((now / 1000) % 2) ? CRGB::Orange : CRGB::Black;
      break;
      
    case LED_GPS_GOOD:
      // Green solid - good GPS fix
      leds[0] = CRGB::Green;
      break;
      
    case LED_LOGGING:
      // Blue fast blinking - logging active
      leds[0] = ((now / 200) % 2) ? CRGB::White : CRGB::Green;
      break;
      
    case LED_ERROR:
      // Red fast blinking - error state
      leds[0] = ((now / 100) % 2) ? CRGB::Red : CRGB::Black;
      break;
      
    case LED_LOW_BATTERY:
      // Yellow slow blinking - low battery
      leds[0] = ((now / 2000) % 2) ? CRGB::Yellow : CRGB::Black;
      break;
      
    case LED_FILE_TRANSFER:
      // Cyan breathing - file transfer
      if (ledDirection) {
        ledBrightness += 3;
        if (ledBrightness >= 200) {
          ledBrightness = 200;
          ledDirection = false;
        }
      } else {
        ledBrightness -= 3;
        if (ledBrightness <= 50) {
          ledBrightness = 50;
          ledDirection = true;
        }
      }
      leds[0] = CRGB(0, ledBrightness, ledBrightness); // Cyan
      break;
      
    case LED_BLE_CONNECTED:
      // White slow pulse - BLE connected
      leds[0] = ((now / 1500) % 2) ? CRGB::Blue : CRGB::Black;
      break;
  }
  
  FastLED.show();
}

// File Transfer Functions
void listSDFiles() {
  if (!sdCardAvailable) {
    sendFileResponse("ERROR:NO_SD_CARD");
    return;
  }
  
  String fileList = "FILES:";
  File root = SD_MMC.open("/");
  if (!root) {
    sendFileResponse("ERROR:CANT_OPEN_ROOT");
    return;
  }
  
  File file = root.openNextFile();
  while (file) {
    if (!file.isDirectory()) {
      String filename = file.name();
      if (filename.endsWith(".bin") || filename.endsWith(".log")) {
        fileList += filename + ":" + String(file.size()) + ";";
      }
    }
    file = root.openNextFile();
  }
  root.close();
  
  sendFileResponse(fileList);
  Serial.println("📁 File list sent: " + fileList);
}

void sendFileResponse(String response) {
  if (fileTransferChar) {
    // Split large responses into chunks
    int maxChunkSize = 500; // BLE MTU considerations
    for (int i = 0; i < response.length(); i += maxChunkSize) {
      String chunk = response.substring(i, min(i + maxChunkSize, (int)response.length()));
      fileTransferChar->setValue(chunk.c_str());
      fileTransferChar->notify();
      delay(50); // Small delay between chunks
    }
  }
}

void startFileTransfer(String filename) {
  if (!sdCardAvailable) {
    sendFileResponse("ERROR:NO_SD_CARD");
    return;
  }
  
  String fullPath = "/" + filename;
  if (!SD_MMC.exists(fullPath.c_str())) {
    sendFileResponse("ERROR:FILE_NOT_FOUND");
    return;
  }
  
  fileTransfer.transferFile = SD_MMC.open(fullPath.c_str(), FILE_READ);
  if (!fileTransfer.transferFile) {
    sendFileResponse("ERROR:CANT_OPEN_FILE");
    return;
  }
  
  fileTransfer.active = true;
  fileTransfer.filename = filename;
  fileTransfer.fileSize = fileTransfer.transferFile.size();
  fileTransfer.bytesSent = 0;
  fileTransfer.lastChunkTime = millis();
  
  setLEDStatus(LED_FILE_TRANSFER);
  
  // Send file info
  String response = "START:" + filename + ":" + String(fileTransfer.fileSize);
  sendFileResponse(response);
  
  Serial.printf("📤 Starting transfer: %s (%d bytes)\n", filename.c_str(), fileTransfer.fileSize);
}

void processFileTransfer() {
  if (!fileTransfer.active || !fileTransfer.transferFile) return;
  
  unsigned long now = millis();
  if (now - fileTransfer.lastChunkTime < 100) return; // Rate limiting
  
  const int chunkSize = 400; // Conservative chunk size for BLE
  uint8_t buffer[chunkSize];
  
  int bytesRead = fileTransfer.transferFile.read(buffer, chunkSize);
  if (bytesRead > 0) {
    // Convert to base64 for reliable BLE transmission
    String chunk = "CHUNK:";
    for (int i = 0; i < bytesRead; i++) {
      chunk += String(buffer[i], HEX);
      if (chunk.length() > 400) break; // Prevent overrun
    }
    
    sendFileResponse(chunk);
    fileTransfer.bytesSent += bytesRead;
    fileTransfer.lastChunkTime = now;
    
    // Progress indicator
    if (fileTransfer.bytesSent % 1000 == 0) {
      float progress = (float)fileTransfer.bytesSent / fileTransfer.fileSize * 100.0f;
      Serial.printf("📤 Transfer progress: %.1f%% (%d/%d bytes)\n", 
        progress, fileTransfer.bytesSent, fileTransfer.fileSize);
    }
  } else {
    // Transfer complete
    fileTransfer.transferFile.close();
    fileTransfer.active = false;
    
    sendFileResponse("COMPLETE:" + String(fileTransfer.bytesSent));
    Serial.printf("✅ Transfer complete: %s (%d bytes)\n", 
      fileTransfer.filename.c_str(), fileTransfer.bytesSent);
    
    // Return to appropriate LED status
    if (loggingActive) {
      setLEDStatus(LED_LOGGING);
    } else if (myGNSS.getFixType() >= 3) {
      setLEDStatus(LED_GPS_GOOD);
    } else {
      setLEDStatus(LED_GPS_SEARCHING);
    }
  }
}

void deleteFile(String filename) {
  if (!sdCardAvailable) {
    sendFileResponse("ERROR:NO_SD_CARD");
    return;
  }
  
  String fullPath = "/" + filename;
  if (SD_MMC.remove(fullPath.c_str())) {
    sendFileResponse("DELETED:" + filename);
    Serial.println("🗑️ Deleted: " + filename);
  } else {
    sendFileResponse("ERROR:DELETE_FAILED");
    Serial.println("❌ Failed to delete: " + filename);
  }
}

// CRC16 calculation
uint16_t crc16(const uint8_t* data, size_t length) {
  uint16_t crc = 0x0000;
  for (size_t i = 0; i < length; i++) {
    crc ^= (uint16_t)data[i] << 8;
    for (uint8_t j = 0; j < 8; j++) {
      if (crc & 0x8000)
        crc = (crc << 1) ^ 0x1021;
      else
        crc <<= 1;
    }
  }
  return crc;
}

// Initialize SD Card with enhanced error handling
bool initSDCard() {
  pinMode(SD_DETECT, INPUT_PULLDOWN);
  delay(100);
  
  if (digitalRead(SD_DETECT) == LOW) {
    Serial.println("❌ No SD card detected");
    setLEDStatus(LED_ERROR);
    return false;
  }
  
  Serial.println("📱 SD card detected, initializing...");
  
  SD_MMC.end();
  delay(100);
  
  if (SD_MMC.setPins(pin_sdioCLK, pin_sdioCMD, pin_sdioD0, pin_sdioD1, pin_sdioD2, pin_sdioD3) == false) {
    Serial.println("❌ SDIO pin assignment failed!");
    setLEDStatus(LED_ERROR);
    return false;
  }
  
  if (SD_MMC.begin() == false) {
    Serial.println("❌ SD_MMC Mount Failed");
    setLEDStatus(LED_ERROR);
    return false;
  }
  
  uint8_t cardType = SD_MMC.cardType();
  if (cardType == CARD_NONE) {
    Serial.println("❌ No SD card detected after mount");
    SD_MMC.end();
    setLEDStatus(LED_ERROR);
    return false;
  }
  
  // Test write capability
  File testFile = SD_MMC.open("/test_write.tmp", FILE_WRITE);
  if (testFile) {
    testFile.println("GPS Logger Test - " + String(millis()));
    testFile.close();
    SD_MMC.remove("/test_write.tmp");
    Serial.println("✅ SD card ready");
    return true;
  } else {
    Serial.println("❌ SD card write test failed");
    SD_MMC.end();
    setLEDStatus(LED_ERROR);
    return false;
  }
}

// Enhanced GNSS configuration
bool configureGNSS() {
  Serial.println("🛰️ Configuring GNSS...");
  setLEDStatus(LED_GPS_SEARCHING);
  
  // Disable NMEA output
  myGNSS.setUART1Output(COM_TYPE_UBX);
  myGNSS.setUART2Output(COM_TYPE_UBX);
  myGNSS.setI2COutput(COM_TYPE_UBX);
  myGNSS.setUSBOutput(COM_TYPE_UBX);
  
  // Disable specific NMEA messages
  myGNSS.disableNMEAMessage(UBX_NMEA_GLL, COM_PORT_UART1);
  myGNSS.disableNMEAMessage(UBX_NMEA_GSA, COM_PORT_UART1);
  myGNSS.disableNMEAMessage(UBX_NMEA_GSV, COM_PORT_UART1);
  myGNSS.disableNMEAMessage(UBX_NMEA_RMC, COM_PORT_UART1);
  myGNSS.disableNMEAMessage(UBX_NMEA_VTG, COM_PORT_UART1);
  myGNSS.disableNMEAMessage(UBX_NMEA_GGA, COM_PORT_UART1);
  
  // Set navigation frequency
  myGNSS.setNavigationFrequency(25);
  myGNSS.setAutoPVT(true);
  myGNSS.setAutoNAVSAT(true);
  
  // Set dynamic model
  if (myGNSS.setDynamicModel(DYN_MODEL_AUTOMOTIVE)) {
    Serial.println("✅ Dynamic model: AUTOMOTIVE");
  } else {
    Serial.println("❌ Failed to set dynamic model");
  }
  
  // Enable GNSS constellations
  myGNSS.enableGNSS(true, SFE_UBLOX_GNSS_ID_GPS);
  myGNSS.enableGNSS(true, SFE_UBLOX_GNSS_ID_GALILEO);
  myGNSS.enableGNSS(true, SFE_UBLOX_GNSS_ID_BEIDOU);
  myGNSS.enableGNSS(true, SFE_UBLOX_GNSS_ID_GLONASS);
  
  Serial.println("✅ GNSS configuration complete");
  return true;
}

// Create log file with GPS timestamp
bool createLogFile() {
  if (!sdCardAvailable) return false;
  
  sprintf(currentLogFilename, "/gps_%04d%02d%02d_%02d%02d%02d.bin",
    myGNSS.getYear(), myGNSS.getMonth(), myGNSS.getDay(),
    myGNSS.getHour(), myGNSS.getMinute(), myGNSS.getSecond());
  
  logFile = SD_MMC.open(currentLogFilename, FILE_WRITE);
  if (!logFile) {
    Serial.println("❌ Failed to create log file");
    setLEDStatus(LED_ERROR);
    return false;
  }
  
  Serial.printf("📄 Created: %s\n", currentLogFilename);
  
  // Write file header
  const char* header = "GPS_LOG_V1.0\n";
  logFile.write((uint8_t*)header, strlen(header));
  logFile.flush();
  
  return true;
}

// Enhanced BLE Configuration Callbacks
class ConfigCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pCharacteristic) {
    String value = pCharacteristic->getValue().c_str();
    if (value.length() == 0) return;
    
    Serial.printf("📝 Config: %s\n", value.c_str());
    
    if (value == "START_LOG") {
      if (sdCardAvailable && myGNSS.getFixType() >= 2) {
        loggingActive = true;
        createLogFile();
        setLEDStatus(LED_LOGGING);
        Serial.println("🔴 Logging started via BLE");
      }
    } else if (value == "STOP_LOG") {
      loggingActive = false;
      if (logFile) {
        logFile.close();
        Serial.println("⚪ Logging stopped via BLE");
      }
      if (myGNSS.getFixType() >= 3) {
        setLEDStatus(LED_GPS_GOOD);
      } else {
        setLEDStatus(LED_GPS_SEARCHING);
      }
    } else if (value == "LIST_FILES") {
      listSDFiles();
    } else if (value.startsWith("DOWNLOAD:")) {
      String filename = value.substring(9);
      startFileTransfer(filename);
    } else if (value.startsWith("DELETE:")) {
      String filename = value.substring(7);
      deleteFile(filename);
    } else if (value == "LED_TEST") {
      // LED test sequence
      setLEDStatus(LED_STARTUP);
      delay(1000);
      setLEDStatus(LED_ERROR);
      delay(1000);
      setLEDStatus(LED_GPS_GOOD);
      delay(1000);
      setLEDStatus(LED_LOGGING);
    }
  }
};

// File Transfer Characteristic Callbacks
class FileTransferCallbacks : public BLECharacteristicCallbacks {
  void onWrite(BLECharacteristic* pCharacteristic) {
    String value = pCharacteristic->getValue().c_str();
    Serial.printf("📤 File command: %s\n", value.c_str());
    
    if (value == "LIST") {
      listSDFiles();
    } else if (value.startsWith("GET:")) {
      String filename = value.substring(4);
      startFileTransfer(filename);
    } else if (value.startsWith("DEL:")) {
      String filename = value.substring(4);
      deleteFile(filename);
    } else if (value == "STOP") {
      if (fileTransfer.active) {
        fileTransfer.transferFile.close();
        fileTransfer.active = false;
        sendFileResponse("STOPPED");
        Serial.println("📤 File transfer stopped");
      }
    }
  }
};

// BLE Server Callbacks
class ServerCallbacks : public BLEServerCallbacks {
  void onConnect(BLEServer* pServer) {
    Serial.println("📱 BLE Client connected");
    setLEDStatus(LED_BLE_CONNECTED);
  }
  
  void onDisconnect(BLEServer* pServer) {
    Serial.println("📱 BLE Client disconnected");
    BLEDevice::startAdvertising();
    
    // Return to appropriate status
    if (loggingActive) {
      setLEDStatus(LED_LOGGING);
    } else if (myGNSS.getFixType() >= 3) {
      setLEDStatus(LED_GPS_GOOD);
    } else {
      setLEDStatus(LED_GPS_SEARCHING);
    }
  }
};

void setup() {
  Serial.begin(115200);
  delay(5000);
  Serial.println("🚀 ESP32 GPS Logger v2.0 Starting...");
  Serial.println("💡 Enhanced: Buttons + OLED + WS2812 LED + File Transfer");
  
  // Initialize LED first for visual feedback
  initLED();
  setLEDStatus(LED_STARTUP);
  
  // Initialize buttons
  pinMode(BUTTON_A_PIN, INPUT_PULLUP);
  pinMode(BUTTON_B_PIN, INPUT_PULLUP);
  
  // Initialize SH1106 OLED display
  u8g2.begin();
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 15, "GPS Logger v2.0");
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(0, 30, "Initializing...");
  u8g2.sendBuffer();
  
  // Initialize I2C and battery monitor
  Wire.begin();
  Serial.println("🔍 Scanning I2C bus...");
  for (uint8_t address = 1; address < 127; address++) {
    Wire.beginTransmission(address);
    if (Wire.endTransmission() == 0) {
      Serial.print("I2C device found at address 0x");
      if (address < 16) Serial.print("0");
      Serial.println(address, HEX);
    }
  }
  Serial.println("🔍 I2C scan complete.");
  
  if (lipo.begin()) {
    lipo.quickStart();
    Serial.println("🔋 Battery monitor ready");
  } else {
    Serial.println("❌ Battery monitor failed");
  }
  
  // Update display
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 15, "GPS Logger v2.0");
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(0, 30, "Init SD Card...");
  u8g2.sendBuffer();
  
  // Initialize SD Card
  sdCardAvailable = initSDCard();
  
  // Update display
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 15, "GPS Logger v2.0");
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(0, 30, "Init GNSS...");
  u8g2.sendBuffer();
  
  // Initialize GNSS
  Serial.println("🛰️ Starting GNSS...");
  GNSS_Serial.begin(921600, SERIAL_8N1, GNSS_RX, GNSS_TX);
  
  if (!myGNSS.begin(GNSS_Serial)) {
    Serial.println("❌ GNSS not detected!");
    setLEDStatus(LED_NO_GPS);
    u8g2.clearBuffer();
    u8g2.setFont(u8g2_font_6x10_tr);
    u8g2.drawStr(0, 15, "GPS Logger v2.0");
    u8g2.setFont(u8g2_font_5x7_tr);
    u8g2.drawStr(0, 30, "GNSS ERROR!");
    u8g2.drawStr(0, 40, "Check connections");
    u8g2.sendBuffer();
    while (1) {
      updateLED();
      delay(100);
    }
  }
  
  myGNSS.setSerialRate(921600);
  delay(100);
  GNSS_Serial.updateBaudRate(921600); 

  if (!configureGNSS()) {
    Serial.println("❌ GNSS configuration failed!");
    setLEDStatus(LED_ERROR);
    while (1) {
      updateLED();
      delay(100);
    }
  }
  
  // Update display
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 15, "GPS Logger v2.0");
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(0, 30, "Init WiFi...");
  u8g2.sendBuffer();
  
  // Initialize WiFi
  Serial.println("📡 Connecting to WiFi...");
  WiFi.begin(ssid, password);
  unsigned long wifiStart = millis();
  while (WiFi.status() != WL_CONNECTED && millis() - wifiStart < 15000) {
    delay(500);
    Serial.print(".");
    updateLED();
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println();
    Serial.println("✅ WiFi connected!");
    Serial.print("📍 IP address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println();
    Serial.println("❌ WiFi connection failed");
  }
  
  // Update display
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 15, "GPS Logger v2.0");
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(0, 30, "Init BLE...");
  u8g2.sendBuffer();
  
  // Initialize BLE
  Serial.println("🔵 Initializing BLE...");
  BLEDevice::init("ESP32_GPS_Logger");
  BLEServer* pServer = BLEDevice::createServer();
  pServer->setCallbacks(new ServerCallbacks());
  
  // Create BLE Service
  BLEService* pService = pServer->createService(telemetryServiceUUID);
  
  // Telemetry characteristic (notify)
  telemetryChar = pService->createCharacteristic(
    telemetryCharUUID,
    BLECharacteristic::PROPERTY_NOTIFY
  );
  telemetryDescriptor = new BLE2902();
  telemetryChar->addDescriptor(telemetryDescriptor);
  
  // Configuration characteristic (write)
  configChar = pService->createCharacteristic(
    configCharUUID,
    BLECharacteristic::PROPERTY_WRITE
  );
  configChar->setCallbacks(new ConfigCallbacks());
  
  // File transfer characteristic (read/write/notify)
  fileTransferChar = pService->createCharacteristic(
    fileTransferCharUUID,
    BLECharacteristic::PROPERTY_READ | 
    BLECharacteristic::PROPERTY_WRITE | 
    BLECharacteristic::PROPERTY_NOTIFY
  );
  fileTransferChar->setCallbacks(new FileTransferCallbacks());
  
  pService->start();
  
  // Start advertising
  BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(telemetryServiceUUID);
  pAdvertising->setScanResponse(true);
  pAdvertising->setMinPreferred(0x06);
  pAdvertising->setMinPreferred(0x12);
  pAdvertising->start();
  
  Serial.println("✅ BLE advertising started");
  
  // Final startup display
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_6x10_tr);
  u8g2.drawStr(0, 15, "GPS Logger v2.0");
  u8g2.setFont(u8g2_font_5x7_tr);
  u8g2.drawStr(0, 30, "System Ready!");
  u8g2.drawStr(0, 45, "A: Navigate");
  u8g2.drawStr(0, 55, "B: Select/Toggle");
  u8g2.sendBuffer();
  
  delay(2000); // Show ready message
  
  Serial.println("🎯 System ready!");
  Serial.println("📱 Button Controls:");
  Serial.println("   A: Navigate menus");
  Serial.println("   B: Select/Enter");
  Serial.println("   Hold A: Quick toggle logging");
  Serial.println("   Hold B: Return to main menu");
  
  setLEDStatus(LED_GPS_SEARCHING);
  perfStats.lastResetTime = millis();
  displayNeedsUpdate = true;
}

void loop() {
  static unsigned long lastPacketTime = 0;
  static unsigned long lastDebugTime = 0;
  static unsigned long lastWiFiCheck = 0;
  static unsigned long lastSDCheck = 0;
  static unsigned long lastBatteryCheck = 0;
  
  // Update LED continuously
  updateLED();
  
  // Process button inputs
  processButtons();
  
  // Update OLED display
  updateDisplay();
  
  // Process file transfers
  processFileTransfer();
  
  // Check battery level periodically
  if (millis() - lastBatteryCheck > 30000) {
    lastBatteryCheck = millis();
    float batteryVoltage = lipo.getVoltage();
    float batteryPercent = lipo.getSOC();
    
    if (batteryPercent < 15 && currentLEDStatus != LED_LOW_BATTERY && currentLEDStatus != LED_ERROR) {
      setLEDStatus(LED_LOW_BATTERY);
    }
    displayNeedsUpdate = true; // Update display when battery changes
  }
  
  // Check WiFi connection periodically  
  if (millis() - lastWiFiCheck > 30000) {
    lastWiFiCheck = millis();
    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("📡 WiFi disconnected, attempting reconnect...");
      WiFi.reconnect();
      displayNeedsUpdate = true;
    }
  }
  
  // Check for SD card insertion/removal periodically
  if (millis() - lastSDCheck > 5000) {
    lastSDCheck = millis();
    bool cardPresent = digitalRead(SD_DETECT) == HIGH;
    if (cardPresent && !sdCardAvailable) {
      Serial.println("📱 SD card inserted, initializing...");
      sdCardAvailable = initSDCard();
      if (sdCardAvailable) {
        Serial.println("✅ SD card ready for logging");
      }
      displayNeedsUpdate = true;
    } else if (!cardPresent && sdCardAvailable) {
      Serial.println("📱 SD card removed");
      sdCardAvailable = false;
      if (logFile) {
        logFile.close();
        loggingActive = false;
        Serial.println("⚪ Logging stopped due to SD card removal");
      }
      SD_MMC.end();
      setLEDStatus(LED_ERROR);
      displayNeedsUpdate = true;
    }
  }
  
  // Process GPS data
  if (myGNSS.getPVT()) {
    unsigned long now = millis();
    unsigned long delta = now - lastPacketTime;
    
    // Update performance stats
    perfStats.totalPackets++;
    if (lastPacketTime > 0) {
      if (delta < perfStats.minDelta) perfStats.minDelta = delta;
      if (delta > perfStats.maxDelta) perfStats.maxDelta = delta;
      perfStats.avgDelta = (perfStats.avgDelta + delta) / 2;
    }
    lastPacketTime = now;
    
    // Update LED status based on GPS fix
    uint8_t fixType = myGNSS.getFixType();
    if (!loggingActive && !fileTransfer.active && currentLEDStatus != LED_LOW_BATTERY) {
      if (fixType >= 3) {
        setLEDStatus(LED_GPS_GOOD);
      } else if (fixType >= 1) {
        setLEDStatus(LED_GPS_SEARCHING);
      } else {
        setLEDStatus(LED_NO_GPS);
      }
    }
    
    // Create GPS packet
    GPSPacket packet;
    packet.timestamp = myGNSS.getUnixEpoch();
    packet.latitude = myGNSS.getLatitude();
    packet.longitude = myGNSS.getLongitude();
    packet.altitude = myGNSS.getAltitude();
    packet.speed = myGNSS.getGroundSpeed();
    packet.heading = myGNSS.getHeading();
    packet.fixType = fixType;
    packet.satellites = myGNSS.getSIV();
    
    // Battery data
    float battV = lipo.getVoltage();
    float soc = lipo.getSOC();
    packet.battery_mv = (uint16_t)(battV * 1000.0f);
    packet.battery_pct = (uint8_t)soc;
    packet.reserved1 = 0x00;
    packet.reserved2 = 0x00;
    packet.reserved3 = 0x00;
    
    // Calculate CRC on the payload (first 28 bytes)
    packet.crc = crc16((uint8_t*)&packet, 28);
    
    // Send via UDP if WiFi connected
    if (WiFi.status() == WL_CONNECTED) {
      udp.beginPacket(remoteIP, remotePort);
      udp.write((uint8_t*)&packet, sizeof(GPSPacket));
      udp.endPacket();
    }
    
    // Send via BLE if connected
    if (telemetryChar && telemetryDescriptor->getNotifications()) {
      telemetryChar->setValue((uint8_t*)&packet, sizeof(GPSPacket));
      telemetryChar->notify();
    }
    
    // Log to SD card if logging active
    if (loggingActive && logFile && sdCardAvailable) {
      size_t written = logFile.write((uint8_t*)&packet, sizeof(GPSPacket));
      if (written != sizeof(GPSPacket)) {
        Serial.println("❌ SD write error");
        perfStats.droppedPackets++;
        setLEDStatus(LED_ERROR);
      } else {
        logFile.flush();
      }
    }
    
    // Update display periodically when GPS data changes
    static uint8_t lastFixType = 0;
    static uint8_t lastSatellites = 0;
    if (fixType != lastFixType || myGNSS.getSIV() != lastSatellites) {
      displayNeedsUpdate = true;
      lastFixType = fixType;
      lastSatellites = myGNSS.getSIV();
    }
    
    // Debug output every 5 seconds (reduced frequency)
    if (now - lastDebugTime >= 5000) {
      lastDebugTime = now;
      
      Serial.printf("📊 GPS: %02d/%02d/%04d %02d:%02d:%02d UTC | ",
        myGNSS.getDay(), myGNSS.getMonth(), myGNSS.getYear(),
        myGNSS.getHour(), myGNSS.getMinute(), myGNSS.getSecond());
      
      Serial.printf("Fix: %d | Sats: %d | ", packet.fixType, packet.satellites);
      Serial.printf("Speed: %.1f km/h | ", packet.speed * 0.0036f);
      Serial.printf("Batt: %.1fV (%d%%)\n", battV, packet.battery_pct);
      
      Serial.printf("⚡ Performance: Δ=%lums (min:%lu, max:%lu, avg:%lu) | ",
        delta, perfStats.minDelta, perfStats.maxDelta, perfStats.avgDelta);
      Serial.printf("Packets: %lu | Dropped: %lu\n", 
        perfStats.totalPackets, perfStats.droppedPackets);
      
      // Reset min/max every debug cycle
      perfStats.minDelta = 9999;
      perfStats.maxDelta = 0;
      
      Serial.printf("🔗 WiFi: %s | BLE: %s | SD: %s | Log: %s | Transfer: %s\n",
        WiFi.status() == WL_CONNECTED ? "✅" : "❌",
        telemetryDescriptor->getNotifications() ? "✅" : "❌",
        sdCardAvailable ? "✅" : "❌",
        loggingActive ? "✅" : "❌",
        fileTransfer.active ? "✅" : "❌");
      
      // Memory usage
      Serial.printf("💾 Free RAM: %d bytes | Free PSRAM: %d bytes\n", 
        ESP.getFreeHeap(), ESP.getFreePsram());
        
      // LED status indicator
      const char* ledStatusNames[] = {
        "STARTUP", "NO_GPS", "GPS_SEARCHING", "GPS_GOOD", 
        "LOGGING", "ERROR", "LOW_BATTERY", "FILE_TRANSFER", "BLE_CONNECTED"
      };
      Serial.printf("💡 LED Status: %s | Menu: %d\n", ledStatusNames[currentLEDStatus], currentMenu);
    }
  }
  
  // Small delay to prevent watchdog issues
  delay(1);
}